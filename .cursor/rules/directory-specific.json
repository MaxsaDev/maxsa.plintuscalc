{
  "name": "Правила для конкретных директорий",
  "description": "Специфичные правила для различных директорий проекта",
  "rules": [
    {
      "pattern": "^actions/.*",
      "instructions": "Actions Directory Rules:\n\n- All files must be Server Actions marked with 'use server'.\n- Functions should perform CRUD operations with the database.\n- Always validate input data using Zod schemas.\n- Return structured responses: { success: boolean, data?: any, error?: string }\n- Handle errors gracefully and return user-friendly error messages.\n- Use meaningful function names: createUser, updatePost, deleteComment.\n- Add JSDoc comments for complex actions.\n\nExample:\n'use server'\n\nimport { z } from 'zod';\nimport { db } from '@/lib/db';\n\nexport async function createUser(data: unknown) {\n  const schema = z.object({ email: z.string().email(), name: z.string() });\n  const validated = schema.parse(data);\n  \n  try {\n    const result = await db.query('INSERT INTO users...');\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error: 'Failed to create user' };\n  }\n}\n\nLeave all comments in the code in Ukrainian"
    },
    {
      "pattern": "^app/.*",
      "instructions": "App Directory Rules:\n\n- Use Next.js 15 App Router conventions.\n- Server Components by default, use 'use client' only when necessary.\n- Export metadata for SEO:\n  export const metadata: Metadata = { title: '...', description: '...' };\n- Use route groups for organizing pages: (auth), (protected), (web).\n- Implement loading.tsx for loading states.\n- Implement error.tsx for error boundaries.\n- Use layout.tsx for shared layouts.\n- Server Components should fetch data directly, no need for useEffect.\n\nLeave all comments in the code in Ukrainian"
    },
    {
      "pattern": "^components/.*",
      "instructions": "Components Directory Rules:\n\n- Keep components small and focused on a single responsibility.\n- Use TypeScript interfaces for props.\n- Implement proper prop validation.\n- Use forwardRef for components that may work with Radix UI's asChild.\n- Add displayName for forwardRef, memo, and HOC components.\n- Export components using named exports.\n- Group related components in subdirectories.\n- components/ui is reserved for third-party UI components (Shadcn).\n\nLeave all comments in the code in Ukrainian"
    },
    {
      "pattern": "^data/.*",
      "instructions": "Data Directory Rules:\n\n- Contains functions for direct database queries.\n- Use parameterized queries to prevent SQL injection.\n- Return typed data using TypeScript interfaces.\n- Handle database errors and return meaningful error messages.\n- Use connection pooling for better performance.\n- Keep queries optimized and use indexes.\n- Separate read and write operations when possible.\n\nExample:\nimport { db } from '@/lib/db';\nimport type { User } from '@/interfaces/user';\n\nexport async function getUserById(id: string): Promise<User | null> {\n  const result = await db.query<User>(\n    'SELECT * FROM users WHERE id = $1',\n    [id]\n  );\n  return result.rows[0] || null;\n}\n\nLeave all comments in the code in Ukrainian"
    },
    {
      "pattern": "^schemas/.*",
      "instructions": "Schemas Directory Rules:\n\n- Use Zod for all validation schemas.\n- Export schemas with descriptive names: registerSchema, loginSchema.\n- Add error messages for better UX:\n  z.string().min(8, { message: 'Password must be at least 8 characters' })\n- Reuse common schemas when possible.\n- Group related schemas together.\n\nExample:\nimport { z } from 'zod';\n\nexport const registerSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n  password: z.string().min(8, { message: 'Password must be at least 8 characters' }),\n  name: z.string().min(2, { message: 'Name must be at least 2 characters' }),\n});\n\nexport type RegisterInput = z.infer<typeof registerSchema>;\n\nLeave all comments in the code in Ukrainian"
    },
    {
      "pattern": "^store/.*",
      "instructions": "Store Directory Rules:\n\n- Use Zustand for global state management.\n- Keep stores small and focused.\n- Use TypeScript for type safety.\n- Implement actions as methods on the store.\n- Use selectors for derived state.\n- Avoid storing server data that should be fetched on-demand.\n- Use persist middleware for data that should survive page reloads.\n\nExample:\nimport { create } from 'zustand';\n\ninterface UserStore {\n  user: User | null;\n  setUser: (user: User | null) => void;\n  logout: () => void;\n}\n\nexport const useUserStore = create<UserStore>((set) => ({\n  user: null,\n  setUser: (user) => set({ user }),\n  logout: () => set({ user: null }),\n}));\n\nLeave all comments in the code in Ukrainian"
    },
    {
      "pattern": "^lib/.*",
      "instructions": "Lib Directory Rules:\n\n- Contains utility functions, helpers, and shared libraries.\n- Keep functions pure when possible (no side effects).\n- Use descriptive names for functions and constants.\n- Export utilities with named exports.\n- Group related utilities in subdirectories.\n- Add JSDoc comments for complex functions.\n- Write unit tests for critical utilities.\n\nLeave all comments in the code in Ukrainian"
    }
  ]
}
