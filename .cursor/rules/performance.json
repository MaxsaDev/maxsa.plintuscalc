{
  "name": "–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏",
  "description": "–ü—Ä–∞–≤–∏–ª–∞ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (—É—á–∏—Ç—ã–≤–∞–µ—Ç React Compiler –≤ Next.js 16)",
  "rules": [
    {
      "pattern": ".*\\.(tsx|jsx|ts|js)$",
      "instructions": "Performance Optimization\n\n‚ö†Ô∏è VERSION-SPECIFIC MEMOIZATION RULES:\n\nFor Next.js 16+ with React Compiler:\n‚ùå AVOID useMemo/useCallback/React.memo in most cases - React Compiler handles automatic memoization\n‚úÖ If you still suggest these hooks, you MUST provide clear justification why automatic optimization is insufficient\n‚úÖ Examples of justified cases:\n  - Complex algorithms that Compiler cannot optimize (provide profiling data)\n  - Third-party library requirements for stable references\n  - Imperative APIs or refs that need stability\n  - Documented performance bottlenecks after testing\n\nFor Next.js 14/15 without React Compiler:\n‚úÖ Use manual memoization hooks when needed:\n  - useMemo for expensive calculations: const value = useMemo(() => compute(a, b), [a, b]);\n  - useCallback for stable callback references: const handler = useCallback(() => {...}, [deps]);\n  - React.memo for components that re-render often with same props\n\nüéØ UNIVERSAL PERFORMANCE RULES (all versions):\n\n1. Server-First Approach:\n- Minimize `'use client'`, `useEffect`, and `setState`\n- ALWAYS favor React Server Components (RSC) as the default\n- Push client boundaries as deep as possible in component tree\n- Compute on server, send HTML to client\n\n2. Component Loading:\n- Wrap client components in Suspense with fallback:\n  <Suspense fallback={<LoadingSpinner />}>\n    <ClientComponent />\n  </Suspense>\n- Use dynamic imports for non-critical components:\n  const Heavy = dynamic(() => import('./Heavy'));\n\n3. Image Optimization:\n- Use WebP format when possible\n- Include width and height attributes\n- Implement lazy loading with loading=\"lazy\"\n- Use Next.js Image component for automatic optimization\n\n4. Avoid Unnecessary Re-renders:\n- Don't create objects/arrays in render\n- Use stable references where needed\n- Split state when possible\n- Prefer derived values over stored state\n\n5. Data Fetching:\n- Preload data on server (SSR)\n- Pass data to client instead of duplicate API calls\n- Follow Next.js docs for Data Fetching, Rendering, and Routing\n\nüéØ STATE AND HOOKS HIERARCHY (in order of preference):\n\n1st: React Server Components (RSC)\n   - Compute on server, no client JavaScript\n   - Default choice for most components\n\n2nd: Pure functions and derived values\n   - Let React Compiler optimize (Next.js 16+)\n   - const fullName = `${firstName} ${lastName}`; // Not useState\n\n3rd: Zustand for shared/global state\n   - When state needs to be shared across components\n   - Avoid local useState if state is used in multiple places\n\n4th: useTransition for async operations\n   - Use for parent components managing multiple UI elements\n   - Pattern: const [isPending, startTransition] = useTransition();\n   - Wrap async calls: startTransition(async () => { await action(); })\n   - Use isPending to disable multiple components simultaneously\n   - Allows React to optimize rendering and keep UI responsive\n   - ‚úÖ Use for: Parent components with lists (e.g., menu items with switches)\n   - ‚úÖ Use for: Forms blocking multiple fields\n\n5th: Local useState for isolated components\n   - For truly local, UI-only state including loading states\n   - Form inputs, modals, toggles, isolated editing components\n   - ‚úÖ Use useState(isLoading) for: Single field editors, isolated components\n   - ‚úÖ Simpler code when component manages its own state\n   - Pattern: const [isLoading, setIsLoading] = useState(false);\n\n6th: useEffect only for side effects\n   - Not for derived data (use calculations instead)\n   - Not for data fetching (use RSC or React Query)\n\n7th: Custom hooks only when needed\n   - If logic can work without hooks - don't create them\n   - Prefer composition over hooks\n\n8th: Manual memoization (last resort in Next.js 16+)\n   - useMemo/useCallback/React.memo\n   - MUST be justified with clear reasoning\n   - Only after profiling shows actual performance issue\n\n‚ùå ANTI-PATTERNS TO AVOID:\n- Using useState for derived data\n- Using useEffect for calculations\n- Creating custom hooks unnecessarily\n- Manual memoization without justification (Next.js 16+)\n- Client components when RSC would work\n- Multiple useEffect calls that could be one or none\n\n‚úÖ DECISION FLOWCHART:\n1. Can it be RSC? ‚Üí Use RSC\n2. Can it be pure function? ‚Üí Use pure function (Compiler optimizes)\n3. Does it need shared state? ‚Üí Use Zustand\n4. Is it parent managing multiple UI elements? ‚Üí Use useTransition\n5. Is it isolated component? ‚Üí Use useState(isLoading)\n6. Does it need local state? ‚Üí Use useState\n7. Does it need side effect? ‚Üí Use useEffect (but verify necessity)\n8. Performance issue? ‚Üí Profile first, then optimize with justification\n\nLeave all comments in the code in Ukrainian"
    }
  ]
}
